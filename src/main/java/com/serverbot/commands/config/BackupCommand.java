package com.serverbot.commands.config;

import com.serverbot.ServerBot;
import com.serverbot.commands.CommandCategory;
import com.serverbot.commands.SlashCommand;
import com.serverbot.utils.CustomEmojis;
import com.serverbot.utils.EmbedUtils;
import com.serverbot.utils.PermissionManager;
import net.dv8tion.jda.api.EmbedBuilder;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.events.interaction.command.SlashCommandInteractionEvent;
import net.dv8tion.jda.api.interactions.commands.OptionMapping;
import net.dv8tion.jda.api.interactions.commands.OptionType;
import net.dv8tion.jda.api.interactions.commands.build.CommandData;
import net.dv8tion.jda.api.interactions.commands.build.Commands;
import net.dv8tion.jda.api.interactions.commands.build.SubcommandData;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

/**
 * Backup and restore system for server configurations
 */
public class BackupCommand implements SlashCommand {

    @Override
    public void execute(SlashCommandInteractionEvent event) {
        if (!event.isFromGuild()) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "Guild Only", "This command can only be used in servers."
            )).setEphemeral(true).queue();
            return;
        }

        Member member = event.getMember();
        if (!PermissionManager.hasPermission(member, "admin.backup")) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "Insufficient Permissions", "You need the `admin.backup` permission to manage server backups."
            )).setEphemeral(true).queue();
            return;
        }

        String subcommand = event.getSubcommandName();
        
        switch (subcommand) {
            case "create" -> handleCreate(event);
            case "list" -> handleList(event);
            case "info" -> handleInfo(event);
            case "restore" -> handleRestore(event);
        }
    }

    private void handleCreate(SlashCommandInteractionEvent event) {
        try {
            String guildId = event.getGuild().getId();
            String guildName = event.getGuild().getName();
            
            // Defer reply as this might take a moment
            event.deferReply().queue();
            
            // Create backup
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String backupName = "backup_" + guildName.replaceAll("[^a-zA-Z0-9]", "_") + "_" + timestamp;
            
            Map<String, Object> guildSettings = ServerBot.getStorageManager().getGuildSettings(guildId);
            
            // Create backup data structure
            StringBuilder backupData = new StringBuilder();
            backupData.append("# Server Bot Configuration Backup\n");
            backupData.append("# Server: ").append(guildName).append(" (").append(guildId).append(")\n");
            backupData.append("# Created: ").append(LocalDateTime.now()).append("\n");
            backupData.append("# DO NOT EDIT THIS FILE MANUALLY\n\n");
            
            int settingsCount = 0;
            for (Map.Entry<String, Object> entry : guildSettings.entrySet()) {
                backupData.append(entry.getKey()).append("=").append(entry.getValue()).append("\n");
                settingsCount++;
            }
            
            // Save backup to storage
            ServerBot.getStorageManager().updateGuildSettings(guildId, "backup_" + timestamp, backupData.toString());
            
            EmbedBuilder embed = EmbedUtils.createEmbedBuilder(EmbedUtils.SUCCESS_COLOR)
                    .setTitle("Backup Created Successfully")
                    .setDescription("Server configuration has been backed up!")
                    .addField("Backup Details", 
                              "**Name:** " + backupName + "\n" +
                              "**Settings Saved:** " + settingsCount + "\n" +
                              "**Created:** " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm")), 
                              false)
                    .addField("Usage", 
                              "Use `/backup list` to view all backups\n" +
                              "Use `/backup restore` to restore from this backup", 
                              false);
            
            event.getHook().sendMessageEmbeds(embed.build()).queue();

        } catch (Exception e) {
            event.getHook().sendMessageEmbeds(EmbedUtils.createErrorEmbed(
                "Backup Failed", 
                "Failed to create backup: " + e.getMessage()
            )).queue();
        }
    }

    private void handleList(SlashCommandInteractionEvent event) {
        try {
            String guildId = event.getGuild().getId();
            Map<String, Object> guildSettings = ServerBot.getStorageManager().getGuildSettings(guildId);
            
            StringBuilder backupList = new StringBuilder();
            int backupCount = 0;
            
            for (Map.Entry<String, Object> entry : guildSettings.entrySet()) {
                if (entry.getKey().startsWith("backup_")) {
                    String timestamp = entry.getKey().substring(7); // Remove "backup_" prefix
                    try {
                        LocalDateTime dateTime = LocalDateTime.parse(timestamp, DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
                        String formattedDate = dateTime.format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm"));
                        backupList.append("**").append(timestamp).append("**\n")
                                 .append("Created: ").append(formattedDate).append("\n\n");
                        backupCount++;
                    } catch (Exception ignored) {
                        // Skip malformed backup entries
                    }
                }
            }
            
            EmbedBuilder embed = EmbedUtils.createEmbedBuilder(EmbedUtils.SUCCESS_COLOR)
                    .setTitle(CustomEmojis.SAVE + " Server Backups")
                    .setDescription("Available configuration backups for **" + event.getGuild().getName() + "**");
            
            if (backupCount == 0) {
                embed.addField(CustomEmojis.NOTE + " No Backups Found", 
                              "Use `/backup create` to create your first backup.", false);
            } else {
                embed.addField(CustomEmojis.NOTE + " Available Backups (" + backupCount + ")", 
                              backupList.toString(), false);
                embed.addField(CustomEmojis.INFO + " Usage", 
                              "Use `/backup info <timestamp>` to view backup details\n" +
                              "Use `/backup restore <timestamp>` to restore a backup", false);
            }
            
            event.replyEmbeds(embed.build()).queue();

        } catch (Exception e) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "List Failed", 
                "Failed to list backups: " + e.getMessage()
            )).setEphemeral(true).queue();
        }
    }

    private void handleInfo(SlashCommandInteractionEvent event) {
        OptionMapping timestampOption = event.getOption("timestamp");
        if (timestampOption == null) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "Missing Parameter", "Please specify the backup timestamp."
            )).setEphemeral(true).queue();
            return;
        }

        try {
            String guildId = event.getGuild().getId();
            String timestamp = timestampOption.getAsString();
            
            Map<String, Object> guildSettings = ServerBot.getStorageManager().getGuildSettings(guildId);
            String backupData = (String) guildSettings.get("backup_" + timestamp);
            
            if (backupData == null) {
                event.replyEmbeds(EmbedUtils.createErrorEmbed(
                    "Backup Not Found", 
                    "No backup found with timestamp: " + timestamp
                )).setEphemeral(true).queue();
                return;
            }
            
            // Parse backup data to count settings
            String[] lines = backupData.split("\n");
            int settingsCount = 0;
            for (String line : lines) {
                if (line.contains("=") && !line.startsWith("#")) {
                    settingsCount++;
                }
            }
            
            LocalDateTime dateTime = LocalDateTime.parse(timestamp, DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String formattedDate = dateTime.format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm"));
            
            EmbedBuilder embed = EmbedUtils.createEmbedBuilder(EmbedUtils.SUCCESS_COLOR)
                    .setTitle(CustomEmojis.SAVE + " Backup Information")
                    .setDescription("Details for backup: **" + timestamp + "**")
                    .addField(CustomEmojis.NOTE + " Created", formattedDate, true)
                    .addField(CustomEmojis.SETTING + " Settings Count", String.valueOf(settingsCount), true)
                    .addField(CustomEmojis.INFO + " Size", backupData.length() + " characters", true)
                    .addField(CustomEmojis.WARN + " Restore Warning", 
                              "Restoring this backup will **overwrite all current settings**!\n" +
                              "Make sure to create a current backup first.", false);
            
            event.replyEmbeds(embed.build()).queue();

        } catch (Exception e) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "Info Failed", 
                "Failed to get backup info: " + e.getMessage()
            )).setEphemeral(true).queue();
        }
    }

    private void handleRestore(SlashCommandInteractionEvent event) {
        OptionMapping timestampOption = event.getOption("timestamp");
        if (timestampOption == null) {
            event.replyEmbeds(EmbedUtils.createErrorEmbed(
                "Missing Parameter", "Please specify the backup timestamp to restore."
            )).setEphemeral(true).queue();
            return;
        }

        try {
            String guildId = event.getGuild().getId();
            String timestamp = timestampOption.getAsString();
            
            // Defer reply as restoration might take time
            event.deferReply().queue();
            
            Map<String, Object> guildSettings = ServerBot.getStorageManager().getGuildSettings(guildId);
            String backupData = (String) guildSettings.get("backup_" + timestamp);
            
            if (backupData == null) {
                event.getHook().sendMessageEmbeds(EmbedUtils.createErrorEmbed(
                    "Backup Not Found", 
                    "No backup found with timestamp: " + timestamp
                )).queue();
                return;
            }
            
            // Parse and restore backup
            String[] lines = backupData.split("\n");
            int restoredCount = 0;
            
            for (String line : lines) {
                if (line.contains("=") && !line.startsWith("#") && !line.startsWith("backup_")) {
                    String[] parts = line.split("=", 2);
                    if (parts.length == 2) {
                        String key = parts[0];
                        String value = parts[1];
                        
                        // Convert string back to appropriate type
                        Object convertedValue;
                        if (value.equals("true") || value.equals("false")) {
                            convertedValue = Boolean.parseBoolean(value);
                        } else if (value.equals("null")) {
                            convertedValue = null;
                        } else {
                            try {
                                convertedValue = Long.parseLong(value);
                            } catch (NumberFormatException e) {
                                convertedValue = value;
                            }
                        }
                        
                        ServerBot.getStorageManager().updateGuildSettings(guildId, key, convertedValue);
                        restoredCount++;
                    }
                }
            }
            
            LocalDateTime dateTime = LocalDateTime.parse(timestamp, DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss"));
            String formattedDate = dateTime.format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm"));
            
            EmbedBuilder embed = EmbedUtils.createEmbedBuilder(EmbedUtils.SUCCESS_COLOR)
                    .setTitle(CustomEmojis.SUCCESS + " Backup Restored Successfully")
                    .setDescription("Server configuration has been restored from backup!")
                    .addField(CustomEmojis.NOTE + " Backup From", formattedDate, true)
                    .addField(CustomEmojis.SETTING + " Settings Restored", String.valueOf(restoredCount), true)
                    .addField(CustomEmojis.INFO + " Status", "All settings have been applied", false)
                    .addField(CustomEmojis.INFO + " Next Steps", 
                              "Your server configuration has been restored to the backed up state.\n" +
                              "You may need to restart the bot for some changes to take effect.", false);
            
            event.getHook().sendMessageEmbeds(embed.build()).queue();

        } catch (Exception e) {
            event.getHook().sendMessageEmbeds(EmbedUtils.createErrorEmbed(
                "Restore Failed", 
                "Failed to restore backup: " + e.getMessage()
            )).queue();
        }
    }

    @Override
    public String getName() {
        return "backup";
    }

    @Override
    public String getDescription() {
        return "Create and restore server configuration backups";
    }

    @Override
    public CommandCategory getCategory() {
        return CommandCategory.CONFIGURATION;
    }

    @Override
    public boolean requiresPermissions() {
        return true;
    }

    @Override
    public boolean isOwnerOnly() {
        return true;
    }

    // Static method for command registration
    public static CommandData getCommandData() {
        return Commands.slash("backup", "Create and restore server configuration backups")
                .addSubcommands(
                        new SubcommandData("create", "Create a backup of current server configuration"),
                        new SubcommandData("list", "List all available backups"),
                        new SubcommandData("info", "View detailed information about a backup")
                                .addOption(OptionType.STRING, "timestamp", "Backup timestamp (from /backup list)", true),
                        new SubcommandData("restore", "Restore server configuration from a backup")
                                .addOption(OptionType.STRING, "timestamp", "Backup timestamp to restore", true)
                );
    }
}
